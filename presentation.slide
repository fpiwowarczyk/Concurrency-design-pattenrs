# Concurrency Design Patterns in GO

Filip Piwowarczyk
filip.piwowarczyk1997@gmail.com
@FilipPiwowarcz3

## Agenda 

1. What is special in go concurrency design 
2. Basic structures 
3. Concurrency design patterns 
4. Fun examples 
5. QnA


## CSP like concurrency 
Golang concurrency mechanisms are based on Communicating Sequential Processes(CSP) language. 
: CSP - language described in paper by Tony Hoare in 1978
: Main idea is that we independed processes can communicate using channels
: Another thing is guarded command that blocks execution until program given statement is true. 
: In golang we can hold process until it receives data through channel, that means we can synchronize two processes by sending data between them. 
.image images/communication.jpg

## CSP like concurrency

Most of languages offers scharing memmory using:
- Locks 
- Mutexes
: You may forget to lock/unlock shared memmory 
: Intruduce race conditions, 
: Deadlock
: Concurrent modifications

Go offers writing well structured, synchronized programs with:
- goroutines 
- channels
: It allows you to write complex synchronization problems in elegant way

## Most importnant concepts 

1. Goroutines 
2. Channels
3. Select statement 
4. Sync package - I guess wont red

## Goroutines

"A gouroutine is a lightweight thread managed by the Go runtime"
: Core concept of concurrency in go
: Managed by Go runtime 
: Should be called when needed, don't try to schedule them by yourself 

.play basic-goroutines.go /START OMIT/,/END OMIT/

: You can see here that as you overcome number of cores 
: scheduling becomes random depending which core will be free

## Channels 

Channels allows to send and receive values. Beside that it allows to synchronize goroutines.
.image
.image  images/channel.png 400 600
: Allows synchronization between goroutines
: Closing sends zero value of type of channel 
: Can be buffered
: TODO Add other info about channels

## Channels 
: It would be great to have better example
.play channels-basic.go /START OMIT/,/END OMIT/

## Select 
Select statement lets gouroutine wait for multiple actions to happend and respond with siutable actions.

.play select-basic.go /START OMIT/,/END OMIT/

## Ping-pong example
.play ping-pong.go /START OMIT/,/END OMIT/



## Patterns
Did you ever had problem with using solution that thereotically you know already enough?
: I have learned things that didn't give me anything before I have to use it and see that 
: usage differs from theory. Thats why I want to present to you these patterns 
.image images/thinker.png 400 300
## Generator 

.play generator.go /START OMIT/,/END OMIT/

## Generator 

.play generator-fib.go /START OMIT/,/END OMIT/


## FanIn

.code fan-in.go /^func Merge/,/^}/

## FanIn

.play fan-in.go /START OMIT/,/END OMIT/

.image images/fan-in.jpg

## FanOut 

.code fanout.go /^func Split/,/^}/

## FanOut
.play fanout.go /START OMIT/,/END OMIT/

.image images/fanout.jpeg 180 400 

## Circuit Breaker 

.play circuit-breaker.go  /START OMIT/,/END OMIT/

## Debounce 

.play debounce.go  /START OMIT/,/END OMIT/

## Throttle

.play throttle.go  /START OMIT/,/END OMIT/




## Plan

Plan: 
1. Przypomnienie czym jest concurrency w go (Szybko była o tym już mowa)
2. Zwrócenie uwagi na ważne elementy concurrency patterns in go 
  a. channel 
  b. goroutine 
  c. select statement 
    I. Example with concurrent program that is hard to controll and refactor it to 
  d. sync package
3. Pokazanie dobrych przykładów kodu z użyciem tych rzeczy 
  a. Generator 
  b. Latch 
  c. FanIn FanOut
  d. Pipeline 
  e. Timeout 


##  Catch phrases

Share by communicating 

Condition variables relay on communicationb by sharing memmory 
Go share by communicating 
When you want to communicate by shering. Communicate thing you want to share, not just information about change in state 
## Asynchronous API 

## Fan-out ? 
This one if wrong, it is better to start goroutine when there is work
``` go 
work :- make(chan Task)
for n := limit; n>0;n-- {
   go func() {
      for task := range wokr {
         perform(task)
      }
   }()

   for _, task := range hugeSlice {
      work <- task
   }
}
```
Good one
``` go 
var wg sync.WaitGroup 
for _ , task := ragne hugeSlice {
  wg.Add(1)
  go func(task Task) {
    perform(task)
    wg.Done()
  }(task)
}

wg.Wait()
```
## Limit for fan-out 
``` go
sem := make(chan token, limit)
for _, task := range hugeSlice {
   sem <- token{} 
   go func(task Task) {
      perform(task)
      <- sem 
   }(task)
}

for n:= limit; n>0;n-- {
   sem <- token{}
}
 

``` 


## Materials used to create these talk 

[CSP paper](https://dl.acm.org/doi/10.1145/359576.359585)
[CSP blog post](https://levelup.gitconnected.com/communicating-sequential-processes-csp-for-go-developer-in-a-nutshell-866795eb879d)

## This is slide with markdown support

.play concurrent-promes.go /START OMIT/,/END OMIT/
